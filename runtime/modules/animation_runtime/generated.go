package animation_runtime

// Code generated by runtime/gen. DO NOT EDIT.

import (
	"fmt"
	"sync"

	"github.com/mitchellh/hashstructure/v2"
	"go.starlark.net/starlark"
	"go.starlark.net/starlarkstruct"

	"tidbyt.dev/pixlet/render"
	"tidbyt.dev/pixlet/render/animation"
	"tidbyt.dev/pixlet/runtime/modules/render_runtime"
)

type AnimationModule struct {
	once   sync.Once
	module starlark.StringDict
}

var animationModule = AnimationModule{}

func LoadAnimationModule() (starlark.StringDict, error) {
	animationModule.once.Do(func() {
		animationModule.module = starlark.StringDict{
			"animation": &starlarkstruct.Module{
				Name: "render",
				Members: starlark.StringDict{

					"AnimatedPositioned": starlark.NewBuiltin("AnimatedPositioned", newAnimatedPositioned),
				},
			},
		}
	})

	return animationModule.module, nil
}

type AnimatedPositioned struct {
	render_runtime.Widget

	animation.AnimatedPositioned

	starlarkChild starlark.Value

	starlarkCurve starlark.Value
}

func newAnimatedPositioned(
	thread *starlark.Thread,
	_ *starlark.Builtin,
	args starlark.Tuple,
	kwargs []starlark.Tuple,
) (starlark.Value, error) {

	var (
		child    starlark.Value
		duration starlark.Int
		curve    starlark.Value
		x_start  starlark.Int
		x_end    starlark.Int
		y_start  starlark.Int
		y_end    starlark.Int
		delay    starlark.Int
		hold     starlark.Int
	)

	if err := starlark.UnpackArgs(
		"AnimatedPositioned",
		args, kwargs,
		"child", &child,
		"duration", &duration,
		"curve", &curve,
		"x_start?", &x_start,
		"x_end?", &x_end,
		"y_start?", &y_start,
		"y_end?", &y_end,
		"delay?", &delay,
		"hold?", &hold,
	); err != nil {
		return nil, fmt.Errorf("unpacking arguments for AnimatedPositioned: %s", err)
	}

	w := &AnimatedPositioned{}

	if child != nil {
		childWidget, ok := child.(render_runtime.Widget)
		if !ok {
			return nil, fmt.Errorf(
				"invalid type for child: %s (expected Widget)",
				child.Type(),
			)
		}
		w.Child = childWidget.AsRenderWidget()
		w.starlarkChild = child
	}

	w.Duration = int(duration.BigInt().Int64())

	w.starlarkCurve = curve
	if curve == nil {
		w.Curve = animation.DefaultCurve
	} else if val, err := CurveFromStarlark(curve); err == nil {
		w.Curve = val
	} else {
		return nil, err
	}

	w.XStart = int(x_start.BigInt().Int64())

	w.XEnd = int(x_end.BigInt().Int64())

	w.YStart = int(y_start.BigInt().Int64())

	w.YEnd = int(y_end.BigInt().Int64())

	w.Delay = int(delay.BigInt().Int64())

	w.Hold = int(hold.BigInt().Int64())

	return w, nil
}

func (w *AnimatedPositioned) AsRenderWidget() render.Widget {
	return &w.AnimatedPositioned
}

func (w *AnimatedPositioned) AttrNames() []string {
	return []string{
		"child", "duration", "curve", "x_start", "x_end", "y_start", "y_end", "delay", "hold",
	}
}

func (w *AnimatedPositioned) Attr(name string) (starlark.Value, error) {
	switch name {

	case "child":

		return w.starlarkChild, nil

	case "duration":

		return starlark.MakeInt(int(w.Duration)), nil

	case "curve":

		return w.starlarkCurve, nil

	case "x_start":

		return starlark.MakeInt(int(w.XStart)), nil

	case "x_end":

		return starlark.MakeInt(int(w.XEnd)), nil

	case "y_start":

		return starlark.MakeInt(int(w.YStart)), nil

	case "y_end":

		return starlark.MakeInt(int(w.YEnd)), nil

	case "delay":

		return starlark.MakeInt(int(w.Delay)), nil

	case "hold":

		return starlark.MakeInt(int(w.Hold)), nil

	default:
		return nil, nil
	}
}

func (w *AnimatedPositioned) String() string       { return "AnimatedPositioned(...)" }
func (w *AnimatedPositioned) Type() string         { return "AnimatedPositioned" }
func (w *AnimatedPositioned) Freeze()              {}
func (w *AnimatedPositioned) Truth() starlark.Bool { return true }

func (w *AnimatedPositioned) Hash() (uint32, error) {
	sum, err := hashstructure.Hash(w, hashstructure.FormatV2, nil)
	return uint32(sum), err
}
