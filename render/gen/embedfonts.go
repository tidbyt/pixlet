package main

import (
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"text/template"
)

const FontDir = "./fonts"
const OutFile = "render/fonts_raw.go"

type Font struct {
	Name    string
	DataB64 string
}

const fontsTemplate = `// Code generated by embedfonts.go, DO NOT EDIT.

package render

var fontDataRaw = map[string]string{
{{range .}} "{{.Name}}": "{{.DataB64}}",
{{end}}
}

`

func main() {
	fontFileInfos, err := ioutil.ReadDir(FontDir)
	if err != nil {
		fmt.Printf("ioutil.ReadDir(%s): %s\n", FontDir, err)
		os.Exit(1)
	}

	fonts := []Font{}
	for _, ffi := range fontFileInfos {
		if !strings.HasSuffix(ffi.Name(), ".bdf") {
			continue
		}

		name := strings.TrimSuffix(ffi.Name(), ".bdf")
		path := fmt.Sprintf("%s/%s", FontDir, ffi.Name())

		content, err := ioutil.ReadFile(path)
		if err != nil {
			fmt.Printf("ioutil.Readfile(%s): %s\n", path, err)
			os.Exit(1)
		}

		fonts = append(fonts, Font{
			Name:    name,
			DataB64: base64.StdEncoding.EncodeToString(content),
		})
	}

	tmpl, err := template.New("fonts").Parse(fontsTemplate)
	if err != nil {
		fmt.Println("template.New().Parse()", err)
		os.Exit(1)
	}

	out, err := os.Create(OutFile)
	if err != nil {
		fmt.Printf("os.Create(%s): %s\n", OutFile, err)
		os.Exit(1)
	}

	err = tmpl.Execute(out, fonts)
	if err != nil {
		fmt.Println("template.Execute()", err)
		os.Exit(1)
	}
}
